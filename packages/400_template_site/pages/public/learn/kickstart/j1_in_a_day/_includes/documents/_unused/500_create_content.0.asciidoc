// Include sub-document
// -----------------------------------------------------------------------------
[role="dropcap"]
The content of a website matters; there is no doubt about that. Therefore,
the first chapter on editing a website should be dedicated to this topic.
Working on the content will be the largest part of all the tasks to create
a website.

As soon as you start work on the first page, you will notice that all
pages are written as a source text. The sources are easy to read as they are
plain text. However, it is not immediately apparent what the resulting page
will look like when the actual HTML target is formatted and generated to be
displayed in a browser.

Using Sources may appear like a disadvantage to some. In particular, those who
have had little contact with sources and their processing. Projects based on
sources follow their laws in processing. Barely someone will be able to create
error-free programs out of the box, nor will website authors create print-ready
pages. Both programmers and authors are initially interested in writing down
what they see on their minds: The concept. This very creative process of
creating the concept would be interrupted again and again unnecessarily if
one also had an eye on the final results.

When working with sources, you will first be interested in the general idea.
With a little practice and experience, you will be able to create the concept
of writing down the skeleton of your idea as a source, which is also technically
and formally correct as of the source text for later translation into a target
system.

JAM-Stack-based websites like J1 are programmed in the best sense. Each project
requires appropriate programming languages; so does J1 Template and the
JAM Stack: The Markup Languages. The sites based on Jekyll and J1 Template
essentially use the markup languages ​​YAML for control and Asciidoc for
formulating the content.

The creation of websites is a craft and art at the same time. The craft
requires suitable tools, the art your creativity. This chapter is designed
to help you with both. Learning the craft and stimulating your creativity.

When working with this section, some new questions will arise. Some of them
could be these questions:

* Which pages already exist?
* How can the existing content used for your pages?
* What types of content does Jekyll support?
* How and in what way does the Jekyll builder engine generate web pages?
* How does the template system J1 support the creation of new pages and
  the modular structure of a website?
* How can recurring components of a website be configured and made re-usable
  with the help of the J1 Template?

Let's start now. Learn how to create modern websites and present the content
optimally using J1 Template.

== Edit and fire up your site

The primary tool for this exploration and editing is the source code editor.
The editor is the swiss army knife, the ultimate tool for daily work on
websites. The editor offers essential functions for fast and reliable
editing of the content, such as creating and adapting the configuration of
the template system.

If not already done, start a new command shell, change the folder to your
J1 project and fire up the build-in website:

.Start the website of your project (Windows)
[source, sh]
----
cls && cd C:\J1\Projects\my-start && j1 site
----

For the following example, the source code editor *Atom* is used. Start your
editor and open your project's folder (the project `my-start` is used for
all the next examples):

.Atom - Project my-start
lightbox::atom--project-my-start[ 800, {data-atom--project-my-start} ]

callout::1[Menu section]
callout::2[Project section, ml-2 mb-3]

[role="mt-3"]
From the project section (2), navigate in the *tree view* to the folder
`pages/public/about` and double-click the file `about_site.adoc` to
open and edit.

== Explore existing content

The quickest and most direct way to gain initial experience in dealing with
a website's content is to examine pages that are already finished, that
already exist. The website built into the J1 Template will help a lot to
understand most of the elements used by the Jekyll engine and J1 Template.
The site supports you to learn the J1 Template in a quite visual way and
helps you to practice everyday routines and procedures.

=== Page blocks

In the editor on the right, you find all open files organized in tabs.
For now, only a single file is opened: the about file `about_site.adoc`.
To work on content pages, typically, you'll have to open multiple files in
your editor, but it is easy to switch from one file to the next using
those tabs.

The following screenshots is showing a typical structure of a content page.
You can identify two main blocks in each of a content file:

* a control block
* a content block

The control block consists of the frontmatter and the prologue section. The
name control block suggests that the control sections are used by the builder
engine for individual page settings. The content block defines the unique
content of a page. Remarkable here is, the block *content* does not contain
any HTML code; no HTML markups.

Assume that the page contains the *source* code for a HTML page that must be
processed by a *magic* first, then it's understandable that writing content
is not done by using HTML code. The page `about_site.adoc` is of type text,
but the file extension is `.adoc`. The reason for that is, this text file
contains source code of Asciidoc markup, not HTML.

.Atom editor - Control block of a page
lightbox::atom--page-about-site-1[ 800, {data-atom--page-about-site-1} ]

callout::1[Frontmatter section ]
callout::2[Prologue section, ml-2 mb-3]

.Atom editor - Content block of a page
lightbox::atom--page-about-site-2[ 800, {data-atom--page-about-site-2} ]

callout::3[Content block, ml-2 mb-3]

[role="mt-3"]
You can guess that the *magic* behind processing the source files has to
do with the Jekyll builder engine. Other magics are provided via the template
system J1 in combination with Jekyll builder engine:

* processing of the (J1) prologue section
* processing Asciidoc code (markups)

This very rough overview should be enough for the time being to do a few
practical things: change existing content.

=== Change existing source pages

The page `about_site` has been discussed already, but how can this page be
accessed? Now, J1's menu system comes into the game. Open the page as shown in
the screenshot.

.Menu bar - Open page "about_site"
lightbox::menubar--open-page-about[ 800, {data-menubar--open-page-about} ]

NOTE: The menu system of J1 is a module, a fairly complex component that
provides a lot of functionality. The menu system supports visitors to get
access to all website pages. Because of the complexity of the menu module,
it makes no sense to talk about it here. In the chapter
link:{j1-kickstart-web-in-a-day--using-modules}[Using Modules, {browser-window--new}],
the navigation system of the J1 Template is discussed and you learn how pages
can be made accessible to visitors via the menu bar.

==== Add an additional paragraph

For a simple change, duplicate the paragraph:

----
Whether you work solo or as part of a team, it’s always a great idea to
help visitors ...
----

Mark the block in your editor and copy (`Ctrl + c`) and paste (`Ctrl + v`)
this block below the existing one and save the file (`Ctrl + s`). In your
shell, you see the changes has been detected and processed.

.Output in the shell running the site
----
YYYY-MM-DD hh:mm:ss - SITE:       Regenerating: 1 file(s) changed at YYYY-MM-DD hh:mm:ss
YYYY-MM-DD hh:mm:ss - SITE:                     pages/public/about/about_site.adoc
YYYY-MM-DD hh:mm:ss - SITE:     J1 QuickSearch: creating search index ...
YYYY-MM-DD hh:mm:ss - SITE:     J1 QuickSearch: finished, index ready.
YYYY-MM-DD hh:mm:ss - SITE:       J1 Paginator: autopages, disabled|not configured
YYYY-MM-DD hh:mm:ss - SITE:       J1 Paginator: pagination enabled, start processing ...
YYYY-MM-DD hh:mm:ss - SITE:       J1 Paginator: finished, processed 2 pagination page|s
YYYY-MM-DD hh:mm:ss - SITE:                     ...done in 9.6753299 seconds.
----

In the webbrowser, the page should has been automatically reloaded and shown
like so:

.Edited page - about_site
lightbox::browser--edited-page-about-1[ 800, {data-browser--edited-page-about-1} ]


[NOTE]
====
By default, Jekyll uses the *Webrick* webserver to `serve` a website in
development mode. Webrick is a simple and Ruby-based webserver quite handy
to run Jekyll as a standalone web application. If Jekyll runs in *incremental*
mode (the default for J1 development), the server shows weird errors like
those if content pages get modified and (automatically) rebuild and reloaded:

----
YYYY-MM-DD hh:mm:ss - SITE: [YYYY-MM-DD hh:mm:ss] ERROR Errno::ECONNABORTED:
                            An established connection was aborted by the software
                            in your host machine.
                            @ io_fillbuf - fd:16
YYYY-MM-DD hh:mm:ss - SITE: PATH_TO_RUBY/lib/ruby/2.7.0/webrick/httpserver.rb:82:in `eof?'
YYYY-MM-DD hh:mm:ss - SITE: PATH_TO_RUBY/lib/ruby/2.7.0/webrick/httpserver.rb:82:in `run'
YYYY-MM-DD hh:mm:ss - SITE: PATH_TO_RUBY/lib/ruby/2.7.0/webrick/server.rb:307:
                            in `block in start_thread'
----

The good news: error messages of this type can be *ignored*. It seems this
is a side-effect of the caching strategy of Jekyll if a site is served in
incremental mode by Webrick. The bad news: no solution has been available to
fix this issue until now. For the time being, please ignore all errors of
this type.
====

==== Modify the Frontmatter

A Frontmatter is a YAML data block and must be the first section in the file
of all content pages. This section is defined by triple-dashed lines to set
predefined variables or set custom ones of your own.

The Frontmatter defines a set of variables and metadata on individual pages
for the Jekyll build-in template engine *Liquid* as well as for the Markup
processing engines to generate HTML code from *Markdown* and *Asciidoc*
sources for the content. The template engine Liquid is used by Jekyll to create
dynamically the common HTML code that is shared by all content pages of a page
layout.

NOTE: Find more information on Liquid with the
link:{url-liquid--user-guide}[Liquid User Guide, {browser-window--new}].

The Markup processing engines transform the content portion of an individual
page into the resulting HTML code. The template engine Liquid and the Markup
processing engines are working closely together. The engine Liquid produces
the HTML code shared by all pages of a specific *layout* and injects the
HTML-code portion generated by the Markup processing engines individually for
a specific content page. Later in this chapter, with section <<Layouts>>,
you'll learn more about the relationship of the processing engines to understand
better how Jekyll (engines) processes the Source Pages of a website.

.Don't repeat yourself
[NOTE]
====
If you don't want to repeat yourself for frequently used Frontmatter
variables over and over, define *defaults* for them and only override them
where necessary. The defauls are configured with the Jekyll site configuration
file `_config.yml` (find examples in section *FRONTMATTER defaults*) .
This works both for predefined (Jekyll) and custom variables.
====

With the help of the Frontmatter, all web pages are customized in a very simple
way. Typical individual settings of websites are the *page title* and the
*tagline*. The page title describes which page it is. The tagline provides
additional information about the content of the page in question.

Other important individual page settings are:

* the description (description), which is displayed in the local search
  (QuickSearch) for hits as a summary of the page
* the keywords generated as (HTML) metadata for each page. Search engines
  use keywords to analyze the content of web pages and contribute to better
  search results
* the categories and tags to organize the content. Categories and tags are
  displayed in the local search (QuickSearch) for hits on a page and can help
  your visitors to classify better a page they have found
* the permalink to optimize the catalogs of search engines (SEO) to simplify
  the URLs of your web pages
* the used J1 modules (resources) of the website, which are not *generally*
  loaded for a page
* the options of the loaded modules (resource_options), which allow individual
  settings for each page

===== Set the page title and/or tagline

Use the `about_site` page again to modify the settings for the variables
title and tagline:

[source, yaml, role="noclip"]
----
title:                                  J1 Template
tagline:                                about
----

Change the tagline like so:

[source, no_template]
----
you should know about
----

and save the page. Creating (HTML) pages are a dynamic process. All changes
to the Frontmatter are *dynamically* applied to the site. Sure, changing the
tagline is a simple example, but it shows Jekyll's *dynamic* behavior. All
values of variables are taken into account in the templates (layouts), and
after re-creating a modified page, they also carry the adjusted settings.

==== Modify the Prologue

The Prologue (Page Initializer) is a feature of the J1 Template. Behind this
are additional settings for the *Asciidoctor* generator, such as additional
programs (procedures) of the template engine Liquid, which are automatically
applied to each page.

The settings for the Asciidoctor generator are formulated as *Asciidoc* markup
language tags. The About page uses the `badges-enabled` tag to control the
output of badges. When the value of the tag `badges-enabled` is set to `true`,
an additional line with badges is generated in the further processing of the
page:

[source, no_template, role="noclip"]
----
  ifeval::[{badges-enabled} == true]
  {badge-j1--license} {badge-j1--version-latest} {badge-j1-gh--last-commit} {badge-j1--downloads}
  endif::[]
----

This is where another *magic* of J1 Template comes into play: procedures for
the template engine Liquid and `attributes` (variables) evalualted by the
Ascidoc processor Asciidoctor. With the help of both, collections of Asciidoc
variables can be processed for a page.

Collections of Asciidoc variables are stored in *files*. The files of these
control variables are named `attributes.asciidoc` and can be found in two
locations:

* global: ~/_includes/attributes.asciidoc (your project folder, e.g. `my-start`)
* local:  <your_page_folder>/_includes/attributes.asciidoc

Asciidoc attributes (variables) defines:

* frequently used URLs
* Frequently used special characters and character chains (strings)
* Author information
* Data on image and video files

The use of variables increases the readability of the source code and can
significantly simplify the notation when using data elements for Asciidoc
macros. Individual Asciidoc variables can be defined and frequently used
attributes can be loaded from files via the prolog of the source code of a
page.

===== Conditional code blocks

With the help of conditional code blocks, you can easily individualize the
content of a page. A simple example of the application is the output of a line
with badges common on the Internet. In the Prolog section of the source code,
you can find the *local* attribute `badges-enabled`. The variable is used to
control a conditional code block. Just rewrite the value of this (Asciidoc)
variable to the value `true`.

[source, no_template]
----
:badges-enabled:                        true
----

This means that the additional code is evaluated when the modified page is
generated and transferred to the output of the HTML page.

TIP: Try to find out what lies behind the attributes of each
Badge (for example: `badge-j1--license`) are hidden.

===== Attributes used for Asciidoc markups

In addition to simple tags, the Asciidoc markup language offers a large set of
macros for generating more complex HTML structures that can be used to integrate
font icons (macro `icon:`) or HTTP hyper links ((macro `link:`) for example.
Asciidoc attributes are very useful and will greatly simplify the notation of
Ascidoc markups for macros.

Add the following code to the `about_site` page and save the changes to
include the additional lines of code in the HTML output:

[source, no_template]
----
A battery symbol is used on the pages of the J1 Template documentation,
which symbolizes the individual level of knowledge for the use of:

* Functions for beginners of template system J1: {level--beginner}
* Functions for users with basic knowledge of J1: {level--intermediate}
* Advanced J1 features: {level--advanced}
* Functions for experts in the application of J1: {level--expert}

You find an overview of all the functions of the template system J1 on the
page link:{url-j1--features}[J1 Template Features, {browser-window--new}].
----

In behind the attribute `{level--xyz}`, the Asciidoctor macro `icon:` is used.
Check the global attribute configuration `~/_includes/attributes.asciidoc`
for more details.

[source, prometheus, role="noclip"]
----
// TAGS, global asciidoc attributes (variables)
// -----------------------------------------------------------------------------
tag::tags[]
...
:icon-battery--quarter:                           icon:battery-quarter[role="md-blue"]
...
// level indicators
//
:level--beginner:                                 {icon-battery--quarter}
----

The notation of the `link:` macro benefits in two ways in terms of
readability:

* the URL parameter is shorter than the actual HTML link and is easier
  to read and understand in the source text due to the symbolic notation
* the additional parameter via the `browser-window--new` attribute is
  self-explanatory. Clicking on this link will open a *new* browser
  tab to display the page and shows the content in a separate window.

=== Complex changes on content sources

For Jekyll, many templates are available that cover all typical use cases for
websites. The bad story: most of them require programming and low-level
customization. Deep knowledge of Jekyll and valuable experience of templating
techniques using HTML, CSS, and Javascript are required.

For J1, This *not* the case if you're using J1. Typical examples of using
the configuration capabilities in conjunction with integrated software of the
the following sections explain the template system.

==== Asciidoc Extensions

Jekyll, like Asciidoctor, is extendable by additional functions. One large
number of plugins are available here. Extensive functional extensions
are usually offered as additional Ruby GEMs. The gem-based ones Plugins
are installed like ordinary GEM and then via the Site configuration
`~/_config.yaml` included.

[source, yaml, role="noclip"]
----
  # ----------------------------------------------------------------------------
  # PLUGIN configuration
  #
  plugins:
    - asciidoctor
    - jekyll-asciidoc
    - jekyll-sitemap
    - j1-paginator
----

For minor extensions that don't necessarily require the procedures of Ruby GEM,
the program code of a plugin is installable in the folder `~_plugins` of the
J1 project. Plugins in the `~_plugins` directory *automatically* integrated
without additional configuration settings. The restriction here compared to
a GEM: The plugin's source must consist of only one file.

.Plugin files and site configuration
lightbox::atom-editor--plugin-files-site-config[ 800, {data-atom-editor--plugin-files-site-config} ]

Many lightweight plugins are already available in the `~_plugins` directory.
All extensions for the Asciidoc markup language or the engine *Asciidoctor*
are stored in the directory  `~_plugins/asciidoctor-extensions`.

The simpler and clearer the website's source code, the better the source to
be read without generating the HTML output. In addition, the code becomes
more compact and generally easier to write down. As simpler the code, the
fewer errors can occur in the notation.

Blocks that result in complex HTML markup in later HTML output are noted
in Asciidoc via macros. Macros are parameterizable markups and the parameters
control how the Asciidoc engine processes to generate target code.

NOTE: There are two AsciiDoc macro types: block and inline. As for all macros,
the block and inline forms differ by the number of colons that follow the macro
name. The *block* form uses *two* colons (::), whereas the inline form only uses
a single one (:).

===== Inline Lorem Macros

Inline macros can either be integrated within a section of the text, for
example, a paragraph, or, like block macros, can create independent code
sections. A good example of using these macros is so-called blind texts,
known as **Lorem-Ipsum** texts. If a new content page is developed, the
content of new articles should be written down in rough sections by the
authors first. The sections outline the idea of what the page is supposed
to describe, but the actual text is (still) unknown.

Blind texts can be a great help when providing sketches of new pages with
a type of text. The sketch will be much more similar to a *real* page with
dummy text and will help the author develop the page's structure and content.

NOTE: You can find examples of dummy texts supported by the J1 template
in the round trip on the page
link:{url-j1-learn--asciidoc_extensions}#blind-text-lorem[Asciidoc Extensions, {browser-window--new}].

The page `about_site.adoc` should be used again for experiments with dummy
texts. Suppose your new website describes your business as a Delivery service
for breakfast buffets. The **About**  pages provide an overview of what
the company can do for customers and what can be found on the pages of your
presence.

A sketch of the content could have the following sections:

* Experience in catering since YYYY
* Your services
** Large selection of national and internal dishes
** Compilation of buffets per person
** Crockery and cutlery service
* Your delivery service
** Delivery areas
** Delivery times and days
* Contact addresses
Contact person PPP +
Service mailbox MMM

These sections can initially be formulated as headings. This skeleton type
makes the page clear whether sections are also be used later for the
*final* text.

.A headings skeleton
[source, no_template]
----
== Experience in catering since YYYY
== Our services
=== Large selection of national and internal dishes
=== Compilation of buffets per person
=== Crockery and cutlery service
== Our delivery service
=== Delivery areas
=== Delivery times and days
== Contact addresses
Contact person PPP +
Service mailbox MMM
----

Copy the *heading skeleton* into the  `about_site.adoc` page. If the page
is newly generated, you will find that pure headings do not look good.
The source text resembles a real skeleton and is not pleasant to read
from this perspective. Writing content is not easy. Terrible source code
and websites are more than terrifying from a psychological point of view.
The motivation at work will suffer, and many things that need to be done
become more tedious and even harder to do.

Change the first headings like this:

[source, no_template]
----
== Experience in catering since YYYY

lorem:sentences[5]

lorem:sentences[7]

== Our services

lorem:sentences[7]

lorem:sentences[5]

=== Large selection of national and internal dishes

lorem:sentences[5]
----

The impression of the page as a source and in the generated web page
changes significantly. Customize the page with additional dummy texts
and replace the placeholders *PPP* and *MMM* with appropriate Lorem macros.

NOTE: Inline macros can be used like block macros if blank lines are
placed around the inline macros. The blank lines create new sections,
as are automatically generated with block macros.

===== Image Block Macros

Complex markup typically includes all elements related to images. These
web page components will never be part of sections: they are separate,
independent parts of a page.

NOTE: The base path for all image-related data is a side-wide (Asciidoc)
configuration (see `_config.yml`) and points per default to `/assets/images`.
The base path is automatically added to each image. If you want to use the
default asset path for images, a relative path needs to be given for
`path/to/image`.

A commonly used Asciidoc **Block** macro to place images on a page is the
`image::` macro:

.Macro to place images
[source, no_template, role="noclip"]
----
.image_title
image::<path_to_image>["<alt_text>", role="<additional CSS styles"]
----

NOTE: The `role` parameter for specifying additional CSS styles is
*optional* in the `image::` macro and can be omitted.

.Beispiel für das Einbinden eines Bilds
image::/assets/images/modules/gallery/old_times/image_01.jpg["GrandPa's 80th Birthday", role="mb-4 wm-800"]

Again, change the content of `about_site` to add a simple image to that page.
To make it simple for now, use the image *GrandPa's 80th Birthday*. Add the
following markup to that page and watch the outcome:

[source, prometheus]
----
.Your added image
image::/assets/images/modules/gallery/old_times/image_01.jpg["GrandPa's 80th Birthday", role="mb-4"]
----

The additional CSS style (role) `mb-4` comes from the *Bootstrap* framework and
adds a `margin` below the image. Play a bit with the additional CSS styles. The
parameter `wm-800` is a CSS style provided by J1 is used to limit the *witdh*
of an block element to a maximum of *800 pixels* in a page. Add the next
snippet below the existing one.

[source, prometheus]
----
.Your added image - Limit the image width
image::/assets/images/modules/gallery/old_times/image_01.jpg["GrandPa's 80th Birthday", role="mb-4 wm-800"]
----

Other, more complex Asciidoc Macros are available with J1 for image-based data
discussed in section <<J1 Modules>>. More configuration changes on a page and
additional configuration is needed to make use of J1 Modules like Lightboxes
and Galleries for image data.

===== Admonition Block Macros

Admonition macros are emphased text elements placed in the running text
but create independent sections. Admonitions are intended to draw the
reader's attention to the text, noted in 5 different levels.

.Macro types
[cols="^4a,8a, subs=+macros, options="header", width="100%", role="rtable mt-3"]
|===
|Name |Example

|`NOTE`
|NOTE: Your text for a *NOTE* goes here.

|`TIP`
|TIP: Your text for a *TIP* goes here.

|`IMPORTANT`
|IMPORTANT: Your text for a *IMPORTANT* message goes here.

|`WARNING`
|WARNING: Your text for a *WARNING* goes here.

|`CAUTION`
|CAUTION: Your text a *CAUTION* message goes here.

|===

Two variants can be used for the notation of Admonition Macros:

.Admonition Markup, simplified
[source, prometheus]
----
NOTE: Your text goes here.
----

.Admonition Markup, block element
[source, prometheus]
----
.Admonition title
[NOTE]
====
Your text goes here.
====
----

The simplified notation is well suited if the text consists of only a few
sentences and only Asciidoc *Inline* macros are used to design the test.
The notation as a *Block* element is necessary if title lines or more
complex block macros such as source blocks or tables are used.

.Admonition using a title
[NOTE]
====
Admonition NOTE written as a block element using a `title` element.
====

Add the `about_site` page again and add various Admonition macros to the
source code. Use both spellings. A **Title** element can also be used for
block notation.


== Anatomy of source pages

You were already able to examine the general structure of a source page
in the <<Page blocks>> section. You learned that the source of a page
consists of the **Control** block and the **content** block. Your
modified `about_site` page might look like this:

.Modified About page
lightbox::pages-about--modified[ 800, {data-pages-about--modified}, role="mb-4" ]

Besides the actual content of the page from the **Content** block
mdi:alpha-c-circle[mdi-md, md-amber], there are a lot of other elements
like that Navigation mdi:alpha-a-circle[mdi-md, md-amber] and page
header mdi:alpha-b-circle[mdi-md, md-amber]. Look at other sites
You'll find that all pages on your site have these elements on your site.

This behavior is explained by the *page model* that the Jekyll builder
engine uses to generate HTML pages. Besides the unique content of a page
from the content block, all pages *inherit* components fundamentally
required for each page. In other words, all pages consist of general
elements that each page has and that unique content.

The structure of an HTML page is complex. In addition to the *visible*
elements displayed in the browser, many other *invisible* HTML elements
are required for a complete web page. For this, take a look at the HTML
code of a web page. Displaying the HTML code can be called up with the
key combination kbd:[Ctrl+U]. The HTML code of the fairly simple page
`about_site` consists of hundreds of lines. The code contains many
invisible HTML elements, which are required for loading the *resources*
used, for example. The resources of a page include the required *CSS styles*
that give a page its shape and **Javascript** components responsible
for the dynamic behavior of pages.

An important promise of the template system J1 is: To create a website
is no programming. No programming is required because all required programs
exist already and are appropriately used by the builder engines to generate
the resulting HTML codes of the pages. Knowledge of the details of these
programs is not necessary, but it is very helpful to know how the HTML
code of a page is created, how the Jekyll builder engine generates the
resulting HTML code from source pages.

=== Layouts

Jekyll's page model for generating HTML code from page sources is difficult
to understand. But even here, it is not necessary to know all the details.
However, you should be familiar with principles: The *layouts*.

Layouts are **construction** templates for HTML pages, each describing a
specific *step* of processing. The resulting HTML code is created by
applying several layouts in a specific order: *inheritance*.

Jekyll applies a strategy of inheriting content along a line of inheritance
to layouts. The unique content is created via the layout of the respective
*page type*. For example, `page` for regular content pages or `post` for
blog posts. Content shared across all pages is described using the `default`
layout. As a very simple picture of processing pages with Jekyll can be the
following (Inheritance) succession are understood:

.Inheritance
[source, no_template, role="noclip"]
----
  HTML-Code < Jekyll < layout-default < layout-page < Source code (Asciidoc)
----

Die Builder-Engine Jekyll liest zunächst den Quelltext einer Seite, beispielsweise
die Seite `about_site`. Diese Seite ist mit dem Layout `page` verbunden. Die
Konstruktionsvorlage `page` verarbeitet zunächst nur die individuellen Anteile
dieser Seite. Layout `page` seinerseits ist mit dem Layout `default` verbunden.
Der Konstruktionsschritt über das Layout `default` ergänzt alle generellen
Komponenten einer Webseite und verbindet (vererbt) die Ergebisse aus dem Layout
`page` mit den Ergebnissen der Verarbeitungen aus dem Layout `default` zu dem
resultierenen HTML-Kode der Seite.

NOTE: Layouts describe which programs are called and in which order.
These programs are associated with configuration data that describes
the details of the work step in question. All Configuration data is in
the project directory `_data`. In this **data** directory, you will find
a folder `layouts` containing control files with the same name for all
available layouts.

.Base layouts
[cols="^2a,4a,6a, subs=+macros, options="header", width="100%", role="rtable mt-3"]
|===
|Layout |Configuration |Description

|`default`
|`_data/layouts/default.yml`
|All general components of a website are generated via the `default`
layout. General components include all resources (assets) such as
CSS and Javascript data responsible for the design and dynamics of
websites.

|`page` \| `post`
|`_data/layouts/page.yml` \| `_data/layouts/post.yml`
|All individual components of a website of type *Page* are generated via
the `page` layout. +
All individual components of a website of type *Post* are generated via
the `post` layout. +
The page components are adjustable individually via the *Frontmatter* of
the source code of posts and pages. The adjustable components include the
(J1) modules used and HTML metadata such as `description` and `keywords`.


|===

IMPORTANT: The template system J1 uses many other layouts. To not completely
go beyond the scope of this tutorial, these layouts will *not* be discussed.

=== Zusammenfassung

As said initially, Jekyll's page model for generating HTML code via layouts
is not easy to understand. The key takeaways from the previous section
should be:

* HTML pages are not created as monolithic blocks but in individual
  steps defined as layouts.
* Layouts take on specific sub-tasks in the generation sequence
* Layouts are linked to each other through an inheritance

If you are interested, the configuration files of the layouts can provide
information about which programs are started to generate the HTML code
of a page in which order.

In the source view of a browser to display the HTML code (kbd:[Ctrl+U]),
you find for each program appropriate (HTML) comments. These comments give
a good overview of how the HTML code came about.


== Create content from scratch

Authors should create source pages from scratch to create their content for a
website. To not start completely from a *blank* page, J1 offers ready-made
skeletons for new source pages. In the `~/pages/public/asciidoc_skeletons`
folder, three different types support different methods of developing
new pages.

.Available Asciidoc skeletons for pages
[cols="^4a,8a, subs=+macros, options="header", width="100%", role="rtable mt-3"]
|===
|Name |Description

|`simple-document`
|Simple documents are used quite often. If the number of chapters is about
or less than three and the document is small in size. This document type
use only *global* Asciidoc include files.

|`multi-document`
|Multi-chapter documents are used for more complex articles of a website. If
the number of chapters is or exceeds three for an article, it could make sense
to split a larger documents chapter-wise into separate files. This document
type is based on  *multiple* Asciidoc documents and make use of local and
global Asciidoc include files.

|`documentation`
|A document of type documentation (book) typically consists in a large
number of chapters and sections. To make this manageable, book-type
documents are splitted in multiple files placed in a nested folder
structure. Complex AsciiDoc projects of type documentation can be worked
on by multiple authors. +
This document type use global and *multiple* local Asciidoc include files.
|===

=== Creating pages

The skeleton of a page based on the template `simple-document` is used for
all further experiments. This template is used very frequently, as many pages
on a website only use a handful of chapters to structure the content.

First, create a superordinate directory `~/pages/public/sandbox` to manage
your new pages. Copy the whole `simple-document` folder from the
`~/pages/public/asciidoc_skeletons` location to your new sandbox folder
`~/pages/public/sandbox`.

CAUTION: If you copy existing content folders that contain documents,
conflicts will arise because the copy creates pages with identical URLs
on the web. After copying, in Frontmatter of the new file, the `permalink`
parameter must be adjusted.

After completing the copy, a few things need to be adjusted:

* Change the name of the folder `simple-document` to `simple-sandbox`
* Open the file `simple.adoc` from this directory and write
  the `permalink` parameter to the value `/pages/public/sandbox/simple/`
  around.

After the generation is complete, the new page is available in your web
*my-site* under the URL:

[source, html]
----
http://localhost:40000/pages/public/sandbox/simple/
----

.New page shown in a Browser
lightbox::pages-skeleton--simple-page[ 1024, {data-pages-skeleton--simple-page}, role="mb-4" ]

TIP: To better understand how the templates work, the three skeletons
generate the same page content but based on a different source model.
The sources are structured completely differently but deliver the same
result in the generated website.

This current content of the template  should not play any role for the
following tests and can be overwritten by more initial settings. Open
the `simple.adoc` page and replace the existing content with the following
code:

.New source code for `simple.adoc`
[source, yaml]
----
---
title:                                  Sandbox
tagline:                                simple sandbox
date:                                   2022-01-01 00:00:00
description: >
                                        Simple documents are used quite often. If the number
                                        of chapters is about or less than three and the document
                                        is small in size. This document type does not use any
                                        (local) Asciidoc include files or attributes.

categories:                             [ Knowledge ]
tags:                                   [ Asciidoc, Sandbox, Document ]

robots:
  index:                                false
  follow:                               false

permalink:                              /pages/public/sandbox/simple/
regenerate:                             false

resources:                              [ animate, clipboard, lightbox, rouge ]
resource_options:
  - toccer:
      collapseDepth:                    3
  - attic:
      padding_top:                      400
      padding_bottom:                   50
      opacity:                          0.5
      slides:
        - url:                          /assets/images/pages/skeleton/antonino-visalli-1920x1280.jpg
          alt:                          Photo by Antonino Visalli on Unsplash
          alignY:                       top
          badge:
            type:                       unsplash
            author:                     Antonino Visalli
            href:                       https://unsplash.com/@_visalli
---

// Page Initializer
// =============================================================================
// Enable the Liquid Preprocessor
:page-liquid:

// Set (local) page attributes here
// -----------------------------------------------------------------------------
// :page--attr:                         <attr-value>


//  Load Liquid procedures
// -----------------------------------------------------------------------------
{% capture load_attributes %}themes/{{site.template.name}}/procedures/global/attributes_loader.proc{%endcapture%}

// Load page attributes
// -----------------------------------------------------------------------------
{% include {{load_attributes}} scope="global" %}


// Page content
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The Asciidoc skeleton *simple-document* a helper for setting up a base file
and folder structure for simple-document AsciiDoc pages based on _Jekyll_ and
_J1 Template_. You need *both* to use this skeleton creating AsciiDoc
documents from it.

// Include sub-documents (if any)
// -----------------------------------------------------------------------------

== Chapter 1

lorem:sentences[5]

== Chapter 2

lorem:sentences[5]

=== Section 1

lorem:sentences[3]
----

==== Content categories

The builder engine *Jekyll* differentiates between two different categories
of content:

* unordered content (pages)
* ordered content (posts)

Thus, all pages of type *Page* are unordered, while all *Blog Posts* are
orderly. The property of order is only of interest to programmers. To make
documents accessible to visitors, navigation options are needed. From the
perspective of the Jekyll engine, there are no options for (automatic)
structuring *Pages* for programmers. For *Posts*, this is quite different.

The Template System J1 structures *Page* and *Post* type documents in its
way. The template provides you with ready-made programs that structure a
website's content and are accessible to visitors via navigation do. Authors
have little exposure to the Jekyll builder engine's elementary delivery
methods to visitors.

J1 provides these  navigation components :

* J1 Navigator, for *Page* type documents
* J1 Blog Navigator, for *Post* type documents

The *Posts Explorer* is used for navigating blog posts and is discussed in
the subsequent <<J1 Blog Navigator>> section. The first thing to look at
is how documents of the *Page* type can be made accessible to your visitors.

==== J1 Navigator

The *J1 Navigator* component is a module in the sense of J1. Modules are
dynamic components and use CSS and Javascript elements to provide the
necessary functionality for a website. One of the features provided
by the module J1 Navigator is the *Menu Bar* that provides visitors
dropdown menus to browse and select content pages.

.Menu managed by the J1 Navigator
lightbox::pages-j1-navigator--menu[ 800, {data-pages-j1-navigator--menu}, role="mb-4" ]

The J1 Navigator module offers several other functions, but changes to
the menu bar are the most common. To manage the menu bar settings more handy,
the settings are separated into a configuration file:
`~/_data/modules/navigator_menu.yml`.

Open this file in your editor. The first impression conveys that the menu
configuration isn't that easy either. The configuration is simple, but
extensive existing settings appear initially complex.

The menu system supports items with and without submenus (dropdowns). The
simplest element in the menu bar is an item that does *not* create any
other **sub**-menus (dropdowns). The configuration for an entry in *Level 0*
has the following form:

.Configuration of a menu entry of level 0
[source, yaml]
----
# ------------------------------------------------------------------------------
# Menu SANDBOX
#
- item:                                 Sandbox
  href:                                 /pages/public/sandbox/simple/
----

Add the configuration from above to the file `~/_data/modules/navigator_menu.yml`
below the entries of the *Learn* menu. The result should then look like this:

.Menu entry of level 0
lightbox::pages-j1-navigator--menu-sandbox[ 800, {data-pages-j1-navigator--menu-sandbox}, role="mb-4" ]

An entry in *Level 1* is helpful to enable a little more options in the
menu entries for sandbox documents. The submenu allows you to call up
different pages as a dropdown. The configuration for an entry in *Level 1*
has the following form:

.Configuration of a menu entry of level 1
[source, yaml]
----
# ------------------------------------------------------------------------------
# Menu SANDBOX
#
- item:                                 Sandbox
  sublevel:

    - title:                            Simple Sandbox page
      href:                             /pages/public/sandbox/simple/
      icon:                             pencil-box-outline
----

.Menu entry of level 1
lightbox::pages-j1-navigator--menu-sandbox-dropdown[ 800, {data-pages-j1-navigator--menu-sandbox-dropdown}, role="mb-4" ]

Drop-down menus offer other advantages:

* All entries can be provided with an *icon*
* All entries have an *individual* text that can help
  visitors to classify the content of a page

The presented configuration of the sandbox shows that entries are not
particularly complicated. Compare the settings of the menu bar of your
site with the menu displayed in the browser. The principle of the menu
configuration will certainly become a lot clearer quickly and will also
help write more extensive entries.

==== J1 Modules

AsciiDoc macros have already been discussed in the <<Asciidoc Extensions>>
section. Asciidoc macros, which make J1 *Modules* usable in websites, are
a little more complex. The use of modules requires additional settings in
configuration files, but again there are none programming required.

J1 modules are *independent* Javascript programs integrated into the template
system. Modules are listed as *Resources* (the actual programs) and integrated
into the template system with the help of *adapters*. The adapters, complemental
Javascript programs, ensure that no programming is required to use the module.
Only suitable *settings* are necessary for using J1 Modules.

TIP: All programs provided and integrated with J1 are *open-source projects*
and can be used *free*.

The task of Ascidoctor Macros for J1 Modules is to generate the necessary
HTML markup within a website, which are required by the connected JavaScript
programs to provide the dynamic functions of the website in the browser. The
settings ensure the desired behavior of a module. The adapters *start* the
respective Javascript programs when the website is displayed in the browser
and run customizations if required.

NOTE: Modules are complex J1 components and are certainly not easy to
understand. From the perspective of non-programming authors, only the
settings of the modules are important. The HTML code of a web page is
discussed in more detail in the <<Monitor a web>> section to understand
better the interaction of modules with the HTML markup of the web pages.
You will get a better insight into the dynamic behavior of web pages in
the browser, and how they managed by J1 modules.

Frequently used Asciidoc macros (for J1 modules) are used to embed
*lightboxes* or *galleries* of images:

.Asciidoc Markup for single images
[source, no_template, role="noclip"]
----
.block_title
lightbox::<block_id>[ <images_width>, <images_data_id>, <role="<additional CSS styles>"> ]
----

.Example of a lightbox for single images
lightbox::images-lightbox-standalone[ 800, {data-images-lightbox--standalone}, role="mb-4"]

If more than a single image is given for a J1 Lightbox block, the images
can be grouped to enable a simple sliding functionality through this group
of related images. Enabling this function, the `group` option needs to be
configured for the macro.

.Asciidoc Markup for groups of images
[source, no_template, role="noclip"]
----
.block_title
lightbox::<block_id>[ <images_width>, <images_data_id>, <group_name>, <role="<additional CSS styles>"> ]
----

.Example of a lightbox displaying groups of images
lightbox::images-lightbox-group[ 395, {data-images-lightbox--group}, lb_group, role="mb-4 wm-800" ]

.Asciidoc Markup for image galleries
[source, no_template, role="noclip"]
----
.block_title
gallery::<gallery_id>[ <role="<additional CSS styles>"> ]
----

.Example of an image gallery
gallery::jg_old_times_2[ role="mb-3 wm-800" ]

NOTE: The `role` parameter for specifying additional CSS styles is
*optional* in all macros and can be omitted.

A Lightbox is a quite simple J1 Module to include single images or groups
of images via a lightbox macro `lightbox::` on a page. In particular,
displaying images for high resolutions using the `image::` macro cannot
be used for original sizes on a page. Lightboxes can help here.
The images are displayed in smaller sizes but can be expanded to their
original resolution by clicking on the image.

Apply the example *Lightbox for single images*  to your new sandbox document
`simple.adoc` below the dummy text of the first chapter. The given source
include the J1 Lightbox Module with an additional dummy text below:

[source, prometheus]
----
lightbox::images-lightbox-standalone[ 800, {data-images-lightbox--standalone}, role="mb-4"]

lorem:sentences[3]
----

The parameters in the Asciidoc markup have the following meaning:

`images-lightbox-standalone`::
All modules require an ID. The Asciidoc macro generates the necessary
HTML markup for the module, but the generated HTML block requires
a unique identifier. Modules can use the *ID* to distinguish between
elements of the same *type* (lightbox for example). For the Lightbox module,
the ID can be freely selected. However, it is advisable to derive the
ID from the attribute's name to make uniqueness of the identifier sure.

`800`::
Limiting the size (width) of the image displayed on the page to 800 pixels.

`data-images-lightbox--standalone`::
The curly brackets address an Asciidoc *attribute*. The definition of
these variables can be found in the *global* ascidoc attributes file
`~/_includes/attributes.asciidoc`.

`role="mb-4"`::
Specifying `mb-4` (Bootstrap style) adds a CSS style for the lightbox
that creates an additional border below the Lightbox element.

In a second step, add the example *Lightbox displaying groups of images*
to the sandbox document below the dummy text in the second chapter.
The Asciidoc code for embedding the lightbox with an additional blind text
is:

[source, prometheus]
----
lightbox::images-lightbox-group[ 395, {data-images-lightbox--group}, lb_group, role="mb-4 wm-800" ]

lorem:sentences[3]
----

The parameters in the Asciidoc markup have the following meaning:

`lb_group`::
The Asciidoc *attribute* `data-images-lightbox--group` contains two images.
To display both images in the *Lightbox*, the parameter `lb_group` creates
a *group* and you can switch between the images.

`role="mb-4 wm-800"`::
Again, the information supplements CSS styles for the lightbox. The
styles apply an additional border below the Lightbox and limit the
element's width on the page to 800 pixels.

The lightbox module is quite simple. Only simple Asciidoc variables are
required to configure the images.

[source, prometheus, role="noclip"]
----
:data-images-lightbox--standalone: "modules/gallery/old_times/image_02.jpg, GrandPa's 80th Birthday"
:data-images-lightbox--group:      "modules/gallery/old_times/image_03.jpg, GrandPa's annual journey, modules/gallery/old_times/image_04.jpg, GrandPa's annual journey"
----

The module of the simple lightbox is very well suited for individual images.
Still, it becomes more difficult to use it for several images, and it is
hardly possible to display more than two or three images as a group in a
meaningful way. Galleries are a better solution for displaying of image
groups, even in large numbers.

The J1 template offers the very powerful **Justified Gallery**-Module for
displaying larger groups of images. The configuration is more extensive
since the module offers significantly more functions. The example
*Image gallery* clearly shows the various functions.

A picture gallery combines two J1 modules:

* a gallery component (JustifiedGallery)
* a powerful lightbox (LightGallery) that adds additional
  functionality to the full-size image display

Most J1 modules are only required on certain pages. Therefore, loading
the required resources only makes sense if the components are used on a
page. Which modules will be loaded for a page configured from the Frontmatter
via the `resources` parameter of a page. To make use of an image gallery,
replace the settings in the Frontmatter of the `simple.adoc` page with the
following code:

.Extendend resources for galleries
[source, yaml]
----
resources:                              [ animate, clipboard, lightbox, lightGallery, justifiedGallery, rouge ]
----

TIP: The need to give additional information about a page's resources
(modules) seems cumbersome. Site visitors reject the best pages with
good design and excellent content if the page takes too long to be
displayed in the browser. In addition to content and design, the
*performance* of a website is essential. Reducing the number of
resources for a page will significantly reduce the time required
to load a page in a web browser.

The macro for embedding an image gallery from the example shown
*macro for image galleries* is:

.Asciidoc Markup for an image gallery plus additional blind text
[source, prometheus]
----
gallery::jg_old_times_2[ role="mb-4 wm-800" ]

lorem:sentences[3]
----

The parameters in the Asciidoc markup have the following meaning:

`jg_old_times_2`::
Like any module, a unique *ID* is required to distinguish elements of
the same *type*. In contrast to the markup of the lightbox `lightbox::`,
this identifier is *not* freely selectable and must correspond to the
ID of the *gallery* from the *configuration* of the module.

`role="mb-3 wm-800"`::
As with the lightbox module, the specifications add CSS styles for
displaying the element on the page.

It is noticeable that the notation of the markup uses fewer parameters
than is the case with the lightbox macro `lightbox::`. The reason for
this is the outsourcing of the settings to a separate configuration file
`~/_data/modules/justifiedGallery.yml`.

.Configuration of the gallery `jg_old_times_2`
[source, yaml]
----
# ----------------------------------------------------------------------------
# Old Times 2
#
- gallery:
    enabled:                        true
    id:                             jg_old_times_2
    type:                           image

    images_path:                    /assets/images/modules/gallery/old_times
    thumb_path:                     /assets/images/modules/gallery/old_times

    images:                         [
                                      image_01.jpg, image_02.jpg,
                                      image_03.jpg, image_04.jpg
                                    ]
    captions_gallery:               [
                                      "GrandPa's 80th Birthday",
                                      "GrandPa's 80th Birthday",
                                      "GrandPa's annual journey",
                                      "GrandPa's annual journey"
                                    ]

    gallery_options:
      rowHeight:                    200
      margins:                      5

    lightbox_options:
      lightbox:                     lg
      mode:                         lg-fade
      cssEasing:                    cubic-bezier(0.25, 0, 0.25, 1)
----

As the last step for this section, expand the Asciidoc markup code of the
image gallery into the new sandbox document below the dummy text in the
second chapter below the *Section 1* section.

How do you like the custom sandbox page now?

By adding images, the sandbox page has taken shape. The page has gained
some dynamic in the browser but can still be read easily in the source
text. The Asciidoc markups remain legible for the author without the website
necessarily being called up in the browser. The decisive advantage of the
Asciidoc markup language: even complex elements can be written down simple,
remain legible, and the meaning stays understood.

=== Creating posts

Das Erstellen von Inhalten für Blog-Beiträge vom Typ *Post* unterscheidet
sich kaum von Artikeln vom Typ *Page*. Alle Asciidoc Markups könnnen
gleichermaßen für bei Typen ohne Ausnahme verwendet werden. Wodurch
unterscheiden sich dann Post und Pages, wenn es nicht die Inhalte sind?

Der Unterschied der beiden Inhaltstypen ist durch die Verfahren der Generierung
bestimmt, die von der Builder-Engine Jekyll für Posts zur Verfügung gestellt
werden. Der Site-Generator link:{url-jekyll--home}[Jekyll, {browser-window--new}]
beschreibt sich als *Blog-Aware*. Die Fähigkeit Blog-Aware soll beschreiben,
dass der Generator besondere Verfahren für diesen Inhaltstyp anbietet und
erweiterte Möglichkeiten für die Verarbeitung von Blogartkeln anbietet.

==== Ordering posts

Wie bereits im Abschnitt <<Content categories>> beschrieben ist der Inhaltstyp
`post` *geordnet*. Anders gesprochen können, im Gegensatz zu Artikeln vom Typ
`page`, können Blogbeiträge *sortiert* werden. Dinge könnten nach Kriterien wie
Größe, Gewicht oder Farbe sortiert werden. Wie sortiert man aber digitale
Inhalte und Wozu?

Im Laufe der Entwicklungsgeschichte von Webpräsentationen im Internet haben
sich verschiedene *Anwendungszwecke* von Websites im World Wide Web (WWW)
herausgebildet. Eine besondere Gruppe von Websites sind hier *Nachrichten-Portale*.
Die Portale verwenden sehr eigene Methoden, um den Besuchern die Inhalte der
Site, also die Nachrichten zur Verfügung zu stellen.

Ein gutes Beispiel für ein solches Nachrichten-Portal ist die
link:{url-ny-times--home}[New York Times, {browser-window--new}]. Das Design
der Seite ist überraschend einfach. Die Seite präsentiert ihrer Inhalte,
also die Nachrichten, als einfache Blöcke die in ihrer Anordung einer
Art von verschieden großen Steinen einer Mauer angeordnet sind. Dieses
**Mansory-Grid**-Layout eignet sich besonders gut, wenn ein sogenanntes
*Portfolio*, eine Sammlung von Inhalten präsentiert werden soll.

Ein ähnliches *Verhalten* zur Anzeige der *Sammlung* von Blogbeiträgen wird
von J1 Template auf der Homepage verwendet. Das Aussehen der *Mauer* wie
die *Steine* (Blöcke) in der Seite ist komplett anders. Dennoch sind die
Darstellungen auf dem Portal der NYT mit der Anzeige in einem J1 Web mit
einander verwandt.

.J1 Home - Latest News
lightbox::images-j1-home-latest-news[ 800, {data-images-j1-home-latest-news}, role="mb-4"]

Eine weitere **Block**-Darstellung von Beiträgen findet sich im J1 Blog-Naviator
auf der Vorschauseite.

.J1 Naviagtor - Preview
lightbox::images-j1-blog-navigator-preview[ 800, {data-images-j1-blog-navigator-preview}, role="mb-4"]

callout::1[Timeline]
callout::2[Article block, ml-2 mb-0]
callout::3[Block header, ml-2 mb-0]
callout::5[Block preview, ml-2 mb-0]
callout::5[Block footer, ml-2 mb-3]

[role="mt-3"]
Ein wichtiges Kriterium zur Ordnung von Nachrichen ist die *Zeit*. Ein Artikel
zum neuesten James-Bond-Film im Kino ergibt nur Sinn, wenn das Jahr klar ist in
dem der Film in die Kinos kommt (Timeline). Jede Nachricht wird in zu eimen
Block zusammengefasst, der eine Art Titel (Header) trägt, einen Auszug
des jeweilgen Beiträgs zeigt und zusätzliche Angaben in einem Footer macht.

Wie die Ordnung über die Zeit zu verstehen ist zeigen die Anzeigen von
Blogartikeln auf der Homepage im Block *Latest News* oder die Seiten
des *J1 Blog Naviagtor*. Alle Artikel werden in *umgekehrter* Reihenfolge
ihres Erscheinens angezeigt, also neue Artikel zuerst.

Der Footer zeigt zwei weitere Ordnungskriterien, die für Blogartikel mit
Jekyll und J1 zur Verfügung stehen:

mdi:tag-text-outline[24px, md-blue mr-2 ml-3]
Categories -- Ordnungskriterium zur *Gruppierung* von Artiklen mit
verwandtem Inhalt +
mdi:tag[24px, md-blue mr-2 ml-3]
Tags -- Ordnungskriterium, dass über den Inhalt eines Artkels Auskunft gibt

Die Angabe von Kategorien und Tags ist zwar auch für Seiten vom Typ *Page*
möglich, jedoch fehlen hier die Möglichkeiten einer automatischen Auswertung
die seitens Jekyll für Blogartikel angeboten werden. Die praktische Anwendung
der Ordnungskriterien werden im folgenden Abschnitt <<J1 Blog Navigator>>
näher erläutert.

==== Writing articles

Wie angesprochen sind bei der  Erstellung von Inhalten keine wesentlichen
Unterschiede zwischen Posts und Pages, jedoch ist die Organisation der
Content-Typen in einem Jekyll-Projekt anders. Liegen die Artkel des Typs
`page` im Ordner `pages`, so liegen alle Artkel des Typs `post` im Verzeichnis
`collections`.

NOTE: In addition to posts, Jekyll offers the article type *Collections* for
organized content, a kind of special form that combines the properties of
posts and pages. Collections extends Jekyll’s post and pages publishing
functionality, and brings to all sorts of *other* types of content that
aren’t dated, but have a relationship with one another. Unfortunately,
collections are not discussed in the tutorial. You can find a good description
to understand collections  in the blog of
link:{url-ben-balter-blog--collections}[Ben Balter, {browser-window--new}].

Ein weiterer wesenlicher Unterschied zu Pages ist der Aufbau der *Dateinamen*
von Blogartikeln. Konnten Sie bei Pages die Namen der Artikel frei vergeben,
ist bei Posts ein festes Schema für die Namen der Quell-Seiten einzuhalten.

To create a post, add the source file to your `_posts` directory using the
following format for the file name:

----
YEAR-MONTH-DAY-<title>.adoc
----

Where `YEAR` is a four-digit number, `MONTH` and `DAY` are both two-digit
numbers, and `adoc` is the file extension representing the format used in
the file. For example, the following are examples of valid post filenames:

----
2021-01-01-about-cookies.adoc
2021-03-28-welcome-to-j1.adoc
----

Like like for pages, all blog post files must begin with a Frontmatter which
is typically used to set a layout or other meta data. Note from here, the
`layout` for posts is `post`.

[source, yaml, role="noclip"]
----
---
layout: post

title:  "Welcome to Jekyll!"
---

== Welcome to Jekyll posts

*Hello world*, this is my first Jekyll blog post.
We hope you like it!
----

Auch bei neuen Blogartikeln müssen Sie nicht von einer leeren Seite zu
beginnen. Eine einfache Vorlage `simple-post` für neue Blogbeiträge steht
Ihnen im Ordner `~/collections/asciidoc_skeletons` zur Verfügung.

.Blog post templates
[cols="^4a,8a", width="100%", options="header", role="rtable mt-3"]
|===
|Name |Description

|`simple-post`
|Simple documents are used quite often. If the number
of chapters is about or less than three and the document
is small in size. This document type does not use any
(local) Asciidoc include files or attributes.

|===

Blogartikel sind vom ihrem Charakter her *Nachrichten*, die von der Seitenlänge
maximal die Größe einfacher Artkel vom Typ `pages` erreichen (sollten). Es ist
denkbar, dass Blogartikel eines Themas sich über mehrere Artikel erstrecken.
Typischer Anwendungsfall sind hier Tutorials, die als Blogartikel organisiert
sind. Das Zusammenfassen von Blogartkeln als eine Serie von Posts mit den
Methoden von J1 erfahren Sie im Abschnitt <<Grouping posts>>.

Legen Sie für die weiteren Schritte einen neuen Artkel an. Ähnlich wie bei
neue Seiten, kopieren Sie dazu das Verzeichnis `simple-post` in den Order
`~/collections/posts/public` und benennen die Quelldatei um. Verwenden Sie
für die neue Quelle im Ordner `~/collections/posts/public/simple-post/_posts`
dazu das jeweils aktuelle Datum, beispielsweise:

[source, text]
----
2022-03-06-new-post.adoc
----

WARNING: Die Quelle der Vorlage hat die Erweiterung `.ascidoc` um die
Generierung eines *echten* Artikels aus der Vorlage zu unterdrücken, da
der Dateiname für Jekyll nicht dem erwarteten *Format* entspricht. Alle
Dateien mit der Erweiterung *.ascidoc* sind über die Einstellungen der
Konfiguration `~/_config.yml` über den Parameter `exclude` ausgeschlossen.

Passen Sie anschließend den Frontmatter der Quelle des neuen Posts nach
Ihren Wünschen an, beispielsweise:

.Frontmatter settings for `simple-post.adoc`
[source, yaml]
----
---
layout:                                 post

title:                                  Your first post article
tagline:                                blog posts from scratch
keywords: >
                                        place, your, keywords, here

categories:                             [ Examples ]
tags:                                   [ Posts, Tutorial ]
---
----

Um wieder mit einer leeren Struktur für den neuen Blogartikel zu beginnen,
überschreiben Sie den Inhalt der Quelle ebenfalls mit einer einfachen
Skelett-Struktur.

.New source code for `simple-post.adoc`
[source, prometheus]
----
// Page content
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Include sub-documents (if any)
// -----------------------------------------------------------------------------

[[readmore]]
== Chapter 1

lorem:sentences[5]

== Chapter 2

lorem:sentences[5]
----

Wie angesprochen sind die Methoden der Entwicklung von Inhalten für Posts keine
anderen als für Pages. Sie können für den neuen Blogartikel die selen
Anpassungen vornehmen, die Sie bereits im Abschnitt <<Creating pages>> für
gewöhnliche (Artikel-)Seiten kennengelernt haben.

Viel Spaß mit den eigenen Experimenten mit den Inhalten der Posts!

==== Categories generated by Jekyll

Tags und Kategorien sind elementare Ordungskriterien für den Content-Typ
`post.` Neben Funktionen zur Auswertung der Kategorien bietet die Builder-Engine
Jekyll eine weitere Eigenschaft: Automatische Kategorisierung von Blogartkeln.
Sie haben die Verzeichnisstruktur `~collections\posts` für den Content-Typ
`post` bereits kennengelernt:

.Folder structure below `collections`
----
  ├─ .
  │  └─ collections <1>
  │     └─ posts <2>
  │        └─ private
  │        └─ protected
  │        └─ public <3>
  │           └─ simple-post <3>
  │              └─ _posts <4>
----
<1> global content folder `collections` (ordered content)
<2> global content folder of the content type `post`
<3> category folders
<4> category content folder `_posts`

Die Ordnerstruktur unterhalb `~collections\posts` dient dem Template-System
*J1* lediglich der Organisation der Artikel. Jedoch Jekyll wertet diese
Ordnerstruktur aus und erzeugt daraus *automatische* Kategorien, die den
jeweilgen *Posts* zugeordnet werden. Aus der Verzeichnisstruktur der leitet
die Builder-Engine automatisch die folgenden Kategorien ab:

* posts
* public
* simple-post

Diese *automatischen* Kategorien werden allen Artiklen im jeweilgen
*category* content folder automatisch zugeordnet. Für native Jekyll-Projekte
ist dies sicher eine gute Möglichkeit, Kategorien über die Builder-Engine
erzeugen zu lassen. Für das Template-System sind die Zuordnungen
automatischer Kategorien *nicht* sehr hilfreich. Bei J1 Projekten sind Tags
wie Kategorien über den Frontmatter der Artikel *explizit* zu konfigurieren.
Die explizite Angabe ist wesentlich flexibler und erlaubt die *spezifische*
Vergabe von Kategorien nach den Vorstellungen der Autoren die unabhängig vom
jeweiligen Speicherort eines Beitrags sind.

Das Erzeugen automatischer Kategorien ist fester Bestandteil von Jekyll und
kann leider *nicht* abgeschaltet werden. Um auf diese Kategorien für die
Verfahren von *J1* zu verzichten, sind entsprechende Einstellungen in der J1
Site Konfiguration `~_data/j1_config.yml` vorzunehmen.

Zur Unterdrückung für die Auswertungen der Layouts über *J1* sind in der
Variablen `category_blacklist` alle *nicht* gewünschten automatischen
Kategorien manuell anzugeben:

.Default settings of `category_blacklist`
[source, yaml, role="noclip"]
----
# ==============================================================================
# POST global configuration settings
#
# NOTE: Set global settings for the Jekyll builder-engine to control
#       the HTML outputs generated by J1
#
# ------------------------------------------------------------------------------
posts:
  # ----------------------------------------------------------------------------
  #   category_blacklist
  #   --------------------------------------------------------------------------
  #   List of categories (automatically) generated by Jekyll to be SKIPPED.
  #   (Additional) Categories are generated by Jekyl from folder names but
  #   NOT used for J1 to be displayed in preview boxes or J1 Posts Navigator
  #   views.
  #
  #   Default:                          [ posts, public, private, protected, featured, series ]
  #
  # ----------------------------------------------------------------------------
  category_blacklist:                   [ posts, public, private, protected, featured, series ]
----

NOTE: Alle *neuen* Blogartikel werden über das Template-System J1
*automatisch* in alle Anzeigen für Posts eingebunden. Einzelheiten
zur Verarbeitung und Anzeige von Posts finden Sie im Abschnitt
<<J1 Blog Navigator>>.

Der neue Blogartikel wurde automatisch über die Vorschau-Boxen des
*Creators Blog* auf der Home Page eingebunden:

.J1 Home - New post article
lightbox::images-j1-home-new-post[ 800, {data-images-j1-home-new-post} ]

In der Vorschau-Box wird die automatische Kategorie `simple-post` jedoch
ausgewertet und angezeigt, da in der Variablen `category_blacklist` der
Eintrag bislang noch *fehlt*. Passen Sie Einstellungen in der in der J1 Site
Konfiguration `~_data/j1_config.yml` entsprechend an:

.Adjusted settings of `category_blacklist`
[source, yaml]
----
    category_blacklist:                   [ posts, public, private, protected, featured, series, simple-post ]
----

==== J1 Blog Navigator

Sie haben gelernt, dass Artikel des Content-Typs `page` über das *Menü*
System des J1 Navigators *manuell* eingebunden werden müssen. Dies ist für
Blogartikel grundsätzlich anders. Alle Artikel des geordneten Contents führen
zu Portfolios, also Sammlungen von Inhalten die über das J1 Modul
*J1 Blog Navigator* verwaltet werden. Ein manuelles Einbinden ist nicht
notwendig. Die Navigator-Komponente verwaltet die Inhalte automatisch. In
allen Anzeigen werden die verfügbaren Blogartikel automatisiert übernommen
und angezeigt. Vergleichbar dem Menü-System für einfache Seiten ermöglicht
der *J1 Blog Navigator* das Surfen in den Inhalten der generierten *Portfolios*.

.J1 Blog Navigator
lightbox::images-j1-blog-navigator[ 800, {data-images-j1-blog-navigator} ]

Der Blog Navigator ist über die Menüleiste über den Eintag *Blog* erreichbar.
Über den Eintrag *Blog Explorer* im Dropdown-Menü erreichen Sie die Hauptseite
des Moduls mit allen verfügbaren Portfolio-**Views**:

* Categories -- articles are grouped by category
* Date -- articles are grouped by date
* Archive -- all articles available sorted from the youngest to the oldest

.J1 Blog Explorer
lightbox::images-j1-blog-navigator-explorer[ 800, {data-images-j1-blog-navigator-explorer}, role="mb-3" ]

callout::1[portfolio viewers (ordered content)]
callout::2[portfolio preview]

[role="mt-3"]
Die Bedienung des Blog Explorers ist sehr einfach und sollte von den Besuchern
der Site intuitiv benutzt werden können. Testen Sie die verschiedenen
Möglichkeiten, die der Explorer über die Portfolio-Views zur Verfügung stellt.
Als Modul kann die Komponente *J1 Blog Navigator* über verschiedene Parameter
konfiguriert werden. Die Einstellungen dazu finden sich im zentralen Verzeichnis
der Modul Konfigurationen unter `~/_data/modules`

* default settings: `defaults\blog_navigator.yml`
* user settings: `blog_navigator.yml`

==== Grouping posts

In einigen Fällen kann es sinnvoll sein, Blogartikel zu einer Gruppe von
verwandten Artikeln zusammenzufassen. Das Layout `post` bietet dazu diese
Möglichkeit, die über die Variable `series` im Frontmatter gesteuert wird.

Um die Funktion der Gruppierung auszuprobieren, erzeugen Sie eine *Kopie* des
existierenden Posts `2022-03-06-new-post.adoc` im selben Verzeichnis und
geben dieser Quelldatei einen neuen Namen:

.Name for the second post
[source, text]
----
2022-03-06-new-post-2.adoc
----

Passen Sie anschließend die *Frontmatter* der beiden Artikel für die
Zusammenfassung als *Gruppe* an. Überschreiben die folgenden Variablen
in *beiden* Artikeln:

.Frontmatter for `simple-post.adoc`
[source, yaml]
----
---
layout:                                 post

title:                                  Your first post article
tagline:                                blog posts from scratch
keywords: >
                                        place, your, keywords, here

categories:                             [ Examples ]
tags:                                   [ Posts, Tutorial ]

image:                                  /assets/images/modules/attics/sigmund-1920x1280.jpg

series:                                 simple-post
regenerate:                             false
---
----

.Frontmatter for `simple-post-2.adoc`
[source, yaml]
----
---
layout:                                 post

title:                                  Your second post article
tagline:                                blog posts from scratch
keywords: >
                                        place, your, keywords, here

categories:                             [ Examples ]
tags:                                   [ Posts, Tutorial ]

image:                                  /assets/images/modules/attics/sigmund-1920x1280.jpg

series:                                 simple-post
regenerate:                             false
---
----

In der Voreinstellung steht der Wert der Variablen im Frontmatter eines
Artikels auf dem Wert `false` und gehören damit zu *keiner* Gruppe. Durch
die Änderung der Variablen `series` im Frontmatter gehören jetzt beide
Artikel der Gruppe `simple-post` an. Öffnen Sie nach Abschluß der Generierung
einen der beiden Artikel über den J1 Blog Explorer:

.J1 Group Explorer
lightbox::images-j1-blog-group-explorer[ 800, {data-images-j1-blog-group-explorer}, role="mb-3" ]

callout::1[group explorer]
callout::2[menu button]
callout::3[group name]

[role="mt-3"]
Über das Template für das Layout `post` von J1 ist ein zusätzliches Element
erzeugt worden: Der Group Explorer. Öffnen Sie über den Menü-Button den
*Group Selector*.

.J1 Group Selector
lightbox::images-j1-blog-group-selector[ 800, {data-images-j1-blog-group-selector}, role="mb-3" ]

Auf einfache Weise sind die Artikel gruppiert und die einzelnen Beiträge
der Gruppe können per Maus-Klick über den Selektor ausgewählt werden.
Grundsätzlich können beliebig viele Artikel gruppiert werden. Dennoch
empfiehlt es sich eine Gruppe auf 3-6 Artikel zu beschränken.

== More about Frontmatter Variables

Vergleichen Sie die bereits existierenden Artikel mit dem Seiten die Sie
angelegt haben fällt eines auf: Bei den existierenden Seiten scheinen scheinen
einige Frontmatter Variablen zu *fehlen*.

Um häufig verwendete Frontmatter-Variablen mit *identischen* Werten nicht immer
wieder wiederholen zu müssen, können für die Variablen im Frontmatter
Standard-Einstellungen verwendet werden. Die Standardwerte der Frontmatter-Variablen
für Ihren Content finden Sie in der Site Konfiguration `/_config.yml` im
Abschnitt *FRONTMATTER defaults*

 Hier definieren Sie Standardwerte und die in den Quellen nur dann überschrieben
 werden wenn es nötig ist. Für alle Artikel vom Content-Typ `page` hat die
 Variable *Layout* den Standardwert `page`, für Posts entsprechend den
 Standardwert `post`. Viele weiteren Variablen können mit Standardwerten belegt
 werden und eine wiederholte Angabe Variablen und deren Werte im Frontmatter
 kann damit vermieden werden.

.Jekyll Variables
[cols="6a,6a", width="100%", options="header", role="table-responsive mt-3"]
|===
|Variable |Description

|`layout`
|The Layout used for a source page.

|`regenerate`
|If the builder-engine Jekyll runs in mode *incremental*, the variable
controls if a source is regenerated *always* (`true`) or only on a
*change* (`false`).

|===

Zur Steuerung der Vorschau von Posts auf der Homepage wird für die Anzeige
von Bildern die Frontmatter Variable `image:` verwendet. Die Variable steuert
welches Bild im *Header* der Anzeigebox verwendet werden soll.

.Available J1 Variables
[cols="6a,6a", width="100%", options="header", role="table-responsive mt-3"]
|===
|Variable |Description

|`title`
|Sets the *title* of a page. Shown in the master header (module attic) and is
used for webbrowsers to name the tab or window..


|`tagline`
|Sets the *subtitle* of a page. Shown in the master header (module attic)
below the title.

|`keywords`
|HTML meta-data key. The data of `keywords` is placed in content key of
`meta name="keywords"`.

|`categories`
|A list *categories* used for the source. Categories are displayed in search
results for all posts and pages. If the content is of type `post`, categories
are shown in the preview boxes and used to order post articles in the
<<J1 Blog Navigator>>.

|`tags`
|A list *tags* used for the source. Tags are displayed in search
results for all posts and pages. If the content is of type `post`, tags
are shown in the preview boxes.

|`image`
|If the content is of type `post`, the *image* is shown in the header of
the preview box of that article.

|`personalization`
|If set to `true`, the page is only available for vistors if they agreed on
*personalization* in the Cookie dialog. If personalization is rejected, the
page is *not* presented and an error page is displayed.

|`exclude_from_search`
|If set to `true` the content page is *not* indexed an *not* displayed in
the search results.

|`series`
|If the content is of type `post`, all posts are grouped by the *group name*
given. If posts should not grouped, use the (default) value of `false`.

|`toc`
|Enables (`true`) or disables (`false`) an auto-generated *table of contents*,
shown in the sidebar of a page.

|`fab_menu_id`
|Defines what *floating action button* should be used fo a page. Valid *id's*
can be found in the *FAB* module configuration `~/_data/modules/fab.yml`

|`scrollbar`
|Enables (`true`) or disables (`false`) the use of the page *scrollbar* in the
webbrowser.

|===

=== Configure Fontmatter defaults

Für die Konfiguration der Standardwerte ist das (YAML) *Array* `defaults:`
in der Site Konfiguration `/_config.yml` verantwortlich. Dieses Array enthält
die (verschachtelten) Listen `scope` und `values`, die jeweils aus
Name-Werte-Paaren bestehen. Klingt zunächst schwierig, ist aber über die
Konfiguration deutlich einfacher zu verstehen.

.Frontmatter defaults from `~/_config.yml` file
[source, yaml]
----
# ------------------------------------------------------------------------------
# FRONTMATTER defaults
#

# Using the YAML Front Matter is a way the (individual) configuration
# for post and pages can be specified. Very often, a lot of config
# options are repeated on each and every post or page. Setting the
# layout for each file, adding categories to a post, etc. might be
# the same for the majority of your content.
#
# Instead of repeating this configuration each time a page is being
# created, Jekyll provides a way to set these configuration items
# as defaults in this site configuration (_config.yml).
#
defaults:

# ----------------------------------------------------------------------------
# PUBLIC - FEATURED
#
- scope:
    path:                             posts/public/featured
    type:                             posts

  values:
    layout:                           post
    author:                           J1 Team
    compress:                         true

  # ----------------------------------------------------------------------------
  # PUBLIC - SERIES
  #
  - scope:
      type:                             posts
      path:                             posts/public/series

    values:
      layout:                           post
      author:                           J1 Team
      compress:                         true
----

WARNING: Alle Konfigurationsdateien in Jekyll bzw. J1 Projekten enthalten
Daten vom Typ `YAML`. Die *Einrückungen* in der Schreibweise der Konfiguration
dienen *nicht* (nur) der besseren Lesbarkeit. Einrückungen sind fester Bestandteil
der Datenstruktur und müssen *exakt* eingehalten werden.

In der gezeigten Konfiguration werden die Standardwerte von *Posts* deklariert,
wobei die Parameter in der Liste `scope` die folgende Bedeutung haben:

* `path`, der *Speicherort* (Verzeichnis) des Contents
* `type`  der zugehörige Content-Type (hier: `post`)

Die Liste `values` enthält die gewünschten Frontmatter Variablen, deren
Standardwerte eingerichtet werden sollen. Eine vollständige Konfiguration der
Standardwerte für Ihre neuen Blogartikel kann die folgenden Einstellungen haben:

.Defaults for the *simple-post* folder
[source, yaml]
----
# ----------------------------------------------------------------------------
# PUBLIC - SIMPLE POST
#
- scope:
    path:                             posts/public/simple-post
    type:                             posts

  values:
    layout:                           post
    author:                           J1 Team
    compress:                         true
    image:                            /assets/images/modules/attics/joanna-kosinska-1920x1280.jpg

    robots:
      index:                          true
      follow:                         true

    personalization:                  false
    exclude_from_search:              false
    series:                           false

    toc:                              true
    fab_menu_id:                      page_ctrl_simple
    scrollbar:                        false

    resource_options:
      - toccer:
          collapseDepth:              3
----

WARNING: Änderungen an den Einstellungen der *Site* Konfiguration
`/_config.yml` erfordern einen *Neustart* der Website.

Ergänzen Sie die Einstellungen von oben in der Konfigurationsdatei
`/_config.yml` unterhalb der bestehenden Einstellungen für Posts im
folgenden Abschnitt:

[source, no_template, role="noclip"]
----
# ----------------------------------------------------------------------------
# POSTS
#
----

Als letzte Anpassungen Ihrer Blogartikel können in den *simple-post* Artikeln
die Variablen `layout` aus den Frontmatter Einstellungen *gelöscht* werden.
Zur *Aktivierung* der Änderungen der Site Konfiguration ist das laufende
Web in der Shell (Windows: Eingabeaufforderung) zu stoppen (kbd:[Ctrl+C])
und anschließend über das Kommando `j1 site` wieder zu starten. Durch die
neuen Frontmatter Defaults können Sie jetzt weitere Anpassungen der Variablen
im Frontmatter machen. Probieren Sie aus, wie sich die Änderungen auswirken.
Das Wissen und die Erfahrung im Umgang mit dem Frontmatter wird sehr helfen,
dass Verhalten Ihrer Seiten auf einfache zur Laufzeit zu ändern.
